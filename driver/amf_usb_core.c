/****************************************************************************** amf_usb_core.c  Amfeltec USB Driver** Copyright (C) 2013-2014, Amfeltec Corp.*****************************************************************************/#include <linux/kernel.h>#include <linux/errno.h>#include <linux/init.h>#include <linux/slab.h>#include <linux/module.h>#include <linux/usb.h>#include "amf_usb.h"#include "amf_usb_utils.h"int myvar; EXPORT_SYMBOL(myvar);typedef enum{        NO_OPERATION,        PRE_EXCHANGE,        POST_EXCHANGE,        EVERYTIME_EXCHANGE} rel2exchange_t;void add_new_node_chunk(u8* data, queue_head_t *queue);void add_node_chunk_data(struct audio_chunk *chunk, u8* data, queue_head_t *queue);void add_node_fill_urb_data(struct usb_tx_urb *tx_urb, u8* data, queue_head_t *queue);void add_node_chunk(struct audio_chunk *chunk, queue_head_t *queue);void add_node_urb (struct usb_tx_urb *urb, queue_head_t *queue);void delete_all(queue_head_t *queue);struct audio_chunk *get_node_chunk(queue_head_t *queue);struct usb_tx_urb *get_node_tx_urb(queue_head_t *queue);struct usb_tx_urb *get_node_urb(queue_head_t *queue);struct list_head *peek_node_chunk(queue_head_t *queue);struct list_head *peek_node_tx_urb(queue_head_t *queue);static int amf_usb_buflen(int rx_in, int rx_out, int max);static int amf_usb_rxdata_get(amf_usb_t *ausb, unsigned char *rxdata, int max_len);static int amf_usb_bh_rx (amf_usb_t *ausb);u8* one_kiloherz[8] = {128, 137, 140, 137, 128, 119, 115, 119};//=========================================================================================================  SYNC  ============================#define SHIFT_INDX 	rx_out++;				\			rx_out = rx_out % MAX_READ_BUF_LENint kdeb_arr[44] = {0};char str1[] = {0x5a, 0xa5};char str2[] = {0x7e, 0x5a};char str3[] = {0x7e, 0x5a, 0xa5};int rx_in_before, rx_in_after, rx_out_store;u32 cnt_print = 0;u8 deb_arr[64];int rx_in_g;u8 deb_arr1[64];int rx_in_g1;void print_command_FXO(amf_usb_t *ausb, cpu_reg_cmd_t*   cmd, char* str, int ack){	u8 *ptr = (u8*) cmd;	if(AMF_USB_CTRL_IDLE_PATTERN == cmd->ctrl){		return;	}	if(AMF_USB_FXO != ausb->amf_device_type){		return;	}	if(!ack && ((0x04 == ptr[0]) || (0x10 == ptr[0]) || (0x1C == ptr[0]))){		printk(KERN_INFO "FXS %s %02X %02X\n", str, 0xFF&ptr[0], 0xFF&ptr[1]);	} else {		printk(KERN_INFO "FXS %s %02X %02X %02X %02X\n", str, 0xFF&ptr[0], 0xFF&ptr[1], 0xFF&ptr[2], 0xFF&ptr[3]);	}}void print_command_FXS(amf_usb_t *ausb, cpu_reg_cmd_t*   cmd, char* str, int ack){	u8 *ptr = (u8*) cmd;	if(AMF_USB_CTRL_IDLE_PATTERN == cmd->ctrl){		return;	}	if(AMF_USB_FXS != ausb->amf_device_type){		return;	}	if(!ack && ((0x04 == ptr[0]) || (0x10 == ptr[0]) || (0x1C == ptr[0]))){		printk(KERN_INFO "FXS %s %02X %02X\n", str, 0xFF&ptr[0], 0xFF&ptr[1]);	} else {		printk(KERN_INFO "FXS %s %02X %02X %02X %02X\n", str, 0xFF&ptr[0], 0xFF&ptr[1], 0xFF&ptr[2], 0xFF&ptr[3]);	}}void print_arr(){	int i;return;	printk(KERN_INFO "---------\n");	for(i = 0; i < 44; i++){		if(kdeb_arr[i]){			printk(KERN_INFO "%d  %d\n", i, kdeb_arr[i]);		}	}}void print16(unsigned char *buf, int val){        unsigned char *p = buf;	printk(KERN_INFO "%d:\t%02X %02X %02X %02X-%02X %02X %02X %02X-%02X %02X %02X %02X-%02X %02X %02X %02X\n", val,        *p, *(p+1), *(p+2), *(p+3), *(p+4), *(p+5), *(p+6), *(p+7), *(p+8), *(p+9), *(p+10), *(p+11), *(p+12), *(p+13), *(p+14), *(p+15));}int amf_usb_syncverify(amf_usb_t *ausb, int len){	int rx_in  = ausb->rx_in;	int rx_out = ausb->rx_out;	int	read_index = 0;	unsigned char* buf;	int i;	if(NULL == ausb){		return 0;	}	A_BUG(ausb == NULL);	if(NULL == ausb->readbuf){		return 0;	}	buf = &(ausb->readbuf[rx_out]);	if (!ausb->rx_sync){		for(i = 0; i < len; i++){			int delta = MAX_READ_BUF_LEN - rx_out;			switch(delta){				case 1:					if(((u8)ausb->readbuf[rx_out] != 0x7E) || (0 != memcmp(ausb->readbuf, str1, 2))){						rx_out = 0;						continue;					} else {						A_DEBUG_USB("%s: Got in sync at %d:%d! len %d\n", AMF_USB_NAME, rx_out, rx_in, len);						ausb->rx_sync = 1;						i = len;						printk(KERN_INFO  "+sync 1 %s  in: %d out: %d\n", __func__, rx_in, rx_out);					}					break;				case 2:					if(((u8)ausb->readbuf[0] != 0xa5) || (0 != memcmp(&(ausb->readbuf[rx_out]), str2, 2))){						rx_out++;						continue;					} else {						A_DEBUG_USB("%s: Got in sync at %d:%d! len %d\n", AMF_USB_NAME, rx_out, rx_in, len);						ausb->rx_sync = 1;						i = len;						printk(KERN_INFO  "+sync 2 %s  in: %d out: %d\n", __func__, rx_in, rx_out);					}					break;				default:					if(0 != memcmp(&(ausb->readbuf[rx_out]), str3, 3)){						rx_out++;						continue;					} else {						A_DEBUG_USB("%s: Got in sync at %d:%d! len %d\n", AMF_USB_NAME, rx_out, rx_in, len);						ausb->rx_sync = 1;						i = len;						printk(KERN_INFO  "+sync default %s  in: %d out: %d\n", __func__, rx_in, rx_out);					}					break;			}		} //while ((!ausb->rx_sync) && (len));	} else {		int delta = (MAX_READ_BUF_LEN - rx_out);		switch(delta){			case 1:				if(((u8)ausb->readbuf[rx_out] != 0x7E) || (0 != memcmp(ausb->readbuf, str1, 2))){					rx_out = 0;					ausb->stats.rx_sync_err_cnt++;					ausb->rx_sync = 0;					ausb->rx_out = rx_out;					printk(KERN_INFO  "-sync 1 %s  in: %d out: %d [%02X  %02X  %02X]\n", __func__, rx_in, rx_out,					(unsigned char)ausb->readbuf[MAX_READ_BUF_LEN - 1],					(unsigned char)ausb->readbuf[0], 					(unsigned char)ausb->readbuf[1]); 					return 0;				}				break;			case 2:				if(((u8)ausb->readbuf[0] != 0xa5) || (0 != memcmp(&(ausb->readbuf[rx_out]), str2, 2))){					rx_out++;					ausb->stats.rx_sync_err_cnt++;					ausb->rx_sync = 0;					ausb->rx_out = rx_out;					printk(KERN_INFO  "-sync 2 %s  in: %d out: %d [%02X  %02X  %02X]\n", __func__, rx_in, rx_out, 					(unsigned char)ausb->readbuf[MAX_READ_BUF_LEN - 2], 					(unsigned char)ausb->readbuf[MAX_READ_BUF_LEN - 1], 					(unsigned char)ausb->readbuf[0]); 					return 0;				}				break;			default:				if(0 != memcmp(&(ausb->readbuf[rx_out]), str3, 3)){					rx_out++;					ausb->stats.rx_sync_err_cnt++;					ausb->rx_sync = 0;					ausb->rx_out = rx_out;					printk(KERN_INFO  "-sync default %s  in: %d out: %d [%02X  %02X  %02X]  before: %d, in_after: %d, out: %d\n", __func__, rx_in, rx_out, 					(unsigned char)ausb->readbuf[rx_out], 					(unsigned char)ausb->readbuf[rx_out+1], 					(unsigned char)ausb->readbuf[rx_out+2], rx_in_before, rx_in_after, rx_out_store);					return 0;				}				break;		}	}	ausb->rx_out = rx_out;	return 1;}int amf_usb_search_rxsync(amf_usb_t *ausb){	int	retry = 0;	do{		if (retry++ > AMF_USBFXO_SYNC_RX_RETRIES) return -EINVAL;		wait_just_a_bit(AMF_USBFXO_SYNC_DELAY, 0);	} while(!ausb->rx_sync);	return 0;}int amf_usb_search_txsync(amf_usb_t *ausb){	int		retry = 0;	do{		if (retry++ > AMF_USBFXO_SYNC_TX_RETRIES) return -EINVAL;		wait_just_a_bit(AMF_USBFXO_SYNC_DELAY, 0);	} while(!ausb->tx_sync);	return 0;}void wait_for_sync(amf_usb_t *ausb, int n){	while(!ausb->rx_sync){		msleep(n);	}}//=========================================================================================================  SYNC.int get_usb_cnt [10] = {0};int put_usb_cnt [10] = {0};//=========================================================================================================  COMPLETION =======================#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)void amf_read_complete(struct urb *q, struct pt_regs *regs)#elsevoid amf_read_complete(struct urb *q)#endif{	struct amf_urb	*aurb = (struct amf_urb*)q->context;	amf_usb_t *ausb;	int		rx_in = 0;	int		rx_out = 0;	int		err, len = 0;	int		i;	int 		indx = aurb->indx;	ausb =               (amf_usb_t*)aurb->pvt;int rx_in_save;static int msg_cnt = 0; 	if(aurb == NULL){		return;	}	if(ausb == NULL){		return;	}	A_BUG(ausb == NULL);	if (q->status){		if (!(q->status == -ENOENT ||q->status == -ECONNRESET || q->status == -ESHUTDOWN)){			A_DEBUG_USB("%s: WARNING: RX transaction failed (%d)!\n",	AMF_USB_NAME, q->status);		}		if(q->status == -EPIPE) {			/* Can't call usb_clear_halt while in_interrupt */			ausb->stats.tx_endpointstall_cnt++;			goto read_complete_done;		}		return;	}/**************************** RS>>> ************************************/ 	ausb->rxcount++;	if (!amf_test_bit(AMF_USB_STATUS_READY, &ausb->status)){		A_DEBUG_USB("%s: WARNING: RX USB core is not ready (%ld:%ld)!\n", AMF_USB_NAME,						ausb->rxcount,(unsigned long)jiffies);		ausb->stats.core_notready_cnt++;		return;	}	A_DEBUG_RX("%s:%d: [RX:%ld]: RX:%d:%02X %d:%02X %d:%02X (%ld)\n",			AMF_USB_NAME, aurb->id, ausb->rxcount,			q->actual_length, ((unsigned char*)q->transfer_buffer)[0],			ausb->next_read_ind, (unsigned char)ausb->readbuf[ausb->next_read_ind],			ausb->next_rx_ind, (unsigned char)ausb->readbuf[ausb->next_rx_ind],			jiffies);	if (!q->actual_length) goto read_complete_done;	get_usb_cnt[ausb->order]++;	ausb->rxbytes = ausb->rxbytes + q->actual_length;	rx_in = ausb->rx_in;	rx_out = ausb->rx_out;	rx_in_before = rx_in;	// Accept data	{		int next = rx_in + q->actual_length;		int delta = MAX_READ_BUF_LEN - rx_in; 		if(next >= MAX_READ_BUF_LEN){			memcpy(&(ausb->readbuf[rx_in]), ausb->readbuf_block[indx], delta);			memcpy(&(ausb->readbuf[0]), &(ausb->readbuf_block[indx][delta]), q->actual_length - delta);			rx_in = next - MAX_READ_BUF_LEN;			rx_in_after = rx_in;			if((rx_out > rx_in_before) || (rx_out <= rx_in_after)){			/* overwrite error -- protect the rest of the buffer *//* RS>>> for while				rx_out = rx_in + 1;				if(MAX_READ_BUF_LEN <= rx_out){					rx_out = 0;				}*/			}			rx_out_store = rx_out;		} else {			memcpy(&(ausb->readbuf[rx_in]), ausb->readbuf_block[indx], q->actual_length);			rx_in = next;			rx_in_after = rx_in;			if((rx_out > rx_in_before) && (rx_out <= rx_in_after)){			/* overwrite error -- protect the rest of the buffer *//* RS>>> for while				rx_out = rx_in + 1;				if(MAX_READ_BUF_LEN <= rx_out){					rx_out = 0;				}*/			}			rx_out_store = rx_out;		}	}	if (rx_in >= rx_out){		len = rx_in - rx_out;	} else {		len = MAX_READ_BUF_LEN - rx_out + rx_in;	}	ausb->rx_len = len;	ausb->rx_in = rx_in;	ausb->rx_out = rx_out;	if (!ausb->firmwareupdate) {		amf_usb_syncverify(ausb, len);	} #ifdef AMF_USB_MODE_SLAVE	if ((ausb->rx_sync) && (len >= MAX_USB_RX_LEN) && (!ausb->firmwareupdate) && (ausb->master_span_on == 0)){		/* Master's tasklet */		tasklet_schedule(&ausb->bh_task);		ausb->usb_master++;	}#else 	if ((ausb->rx_sync) && (len >= (MAX_USB_RX_LEN)) && (!ausb->firmwareupdate)){		/* Master's tasklet */		tasklet_schedule(&ausb->bh_task);		ausb->usb_master++;	}else{}#endifread_complete_done:	q->transfer_buffer = ausb->readbuf_block[indx]; 	err = usb_submit_urb(&aurb->urb, GFP_ATOMIC);	if ((err != 0) && (err != -ENOENT)) {		A_DEBUG_USB("%s: usb_submit %p returns %d (%s)\n", AMF_USB_NAME, aurb, err,					amf_test_bit(AMF_URB_STATUS_READY, &aurb->ready)?"Ready":"Busy");	}	return;}#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)void amf_write_complete(struct urb *q, struct pt_regs *regs)#elsevoid amf_write_complete(struct urb *q)#endif{	struct usb_tx_urb* tx_urb_item = (struct usb_tx_urb*)q->context;	amf_usb_t		*ausb =	tx_urb_item->ausb;	put_usb_cnt[ausb->order]++;	if(NULL == tx_urb_item){	}	KFREE(tx_urb_item, 19);	return;	ausb->txcount++;	if (q->status){		if (!(q->status == -ENOENT ||q->status == -ECONNRESET || q->status == -ESHUTDOWN || q->status == -EPIPE)){			A_DEBUG("%s: WARNING: TX transaction failed (%d)!\n", AMF_USB_NAME, q->status);		}		if(q->status == -EPIPE) {			/* Can't call usb_clear_halt while in_interrupt */			ausb->stats.rx_endpointstall_cnt++;		}		return;	}	if (!amf_test_bit(AMF_USB_STATUS_READY, &ausb->status)){		A_DEBUG_USB("%s: WARNING: TX USB core is not ready (%ld:%ld)!\n", AMF_USB_NAME, ausb->txcount,	jiffies);		ausb->stats.core_notready_cnt++;		return;	}	if ((q->actual_length < MAX_USB_TX_LEN) && (!ausb->firmwareupdate)) {		A_DEBUG_USB("%s: WARNING: Tx length < MAX(%d:%d)\n", AMF_USB_NAME, q->actual_length, MAX_USB_TX_LEN);	}	/* Mark this urb as ready */	amf_set_bit(AMF_USB_STATUS_TX_READY, &ausb->status);}//=========================================================================================================  COMPLETION END//=========================================================================================================  ENDPOINTS & URBS  ================//RS>>>int amf_usb_set_receive_urbs(struct usb_interface *interface, struct usb_endpoint_descriptor *endpoint) {	struct usb_host_interface *iface_desc;	struct amf_usb *ausb;	int i;	int x;	ausb = usb_get_intfdata(interface);	iface_desc = interface->cur_altsetting;	x = 0;	for (i = 0; i < AMF_URB_AMOUNT; i++) {		{#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)			ausb->readbuf_block[i] = usb_buffer_alloc(ausb->udev, AMF_URB_BULK_BUF_SIZE,                			GFP_ATOMIC, &ausb->urbread[x][i].urb.transfer_dma);#else                        ausb->readbuf_block[i] = usb_alloc_coherent(ausb->udev, AMF_URB_BULK_BUF_SIZE,                                        GFP_ATOMIC, &ausb->urbread[x][i].urb.transfer_dma);#endif			if (NULL == ausb->readbuf_block[i]){				i--;				while(i > 0){					if(NULL !=  ausb->readbuf_block[i]){#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)						usb_buffer_free(ausb->udev, AMF_URB_BULK_BUF_SIZE, ausb->readbuf_block[i],						ausb->urbread[x][i].urb.transfer_dma);#else                                                usb_free_coherent(ausb->udev, AMF_URB_BULK_BUF_SIZE, ausb->readbuf_block[i],                                                ausb->urbread[x][i].urb.transfer_dma);#endif					}					i--;				}				return -ENOMEM;			}			ausb->urbread[x][i].indx = i;	              ausb->urbread[x][i].pvt = ausb;			usb_init_urb(&ausb->urbread[x][i].urb);			usb_fill_bulk_urb (				&ausb->urbread[x][i].urb,				ausb->udev,				usb_rcvbulkpipe (ausb->udev, endpoint->bEndpointAddress),				&ausb->readbuf_block[i][0],				AMF_URB_BULK_BUF_SIZE,				amf_read_complete,				&ausb->urbread[x][i]);	//p  		}	}	return 0;}void amf_usb_set_transfer_urbs(struct usb_interface *interface) {	struct usb_host_interface *iface_desc;	struct usb_endpoint_descriptor *endpoint;	struct amf_usb *ausb;	int i;	int x;	ausb = usb_get_intfdata(interface);	iface_desc = interface->cur_altsetting;	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {		endpoint = &iface_desc->endpoint[i].desc;		if (usb_endpoint_is_bulk_in(endpoint)) {			A_DEBUG("%s: Bulk IN EP Address:%X MaxLen:%d, i=%d\n", AMF_USB_NAME, endpoint->bEndpointAddress, endpoint->wMaxPacketSize, i);			amf_usb_set_receive_urbs(interface, endpoint);		}		if (usb_endpoint_is_bulk_out(endpoint)) {			A_DEBUG("%s: Bulk OUT EP Address:%X MaxLen:%d, i=%d\n", AMF_USB_NAME, endpoint->bEndpointAddress, endpoint->wMaxPacketSize, i);			ausb->tx_pipe = usb_sndbulkpipe (ausb->udev, endpoint->bEndpointAddress);		}	}	return;}struct usb_tx_urb* amf_usb_init_tx_urb(struct amf_usb *ausb, struct usb_tx_urb* tx_urb_item){	usb_init_urb(&tx_urb_item->urb);	usb_fill_bulk_urb (		&tx_urb_item->urb,		ausb->udev,		ausb->tx_pipe,		tx_urb_item->data,		MAX_USB_TX_LEN,		amf_write_complete,		tx_urb_item);	return tx_urb_item;}struct usb_tx_urb* amf_usb_init_tx_urb_len(struct amf_usb *ausb, struct usb_tx_urb* tx_urb_item, int len){	usb_init_urb(&tx_urb_item->urb);	usb_fill_bulk_urb (		&tx_urb_item->urb,		ausb->udev,		ausb->tx_pipe,		tx_urb_item->data,		len,		amf_write_complete,		tx_urb_item);	return tx_urb_item;}//=========================================================================================================   URB STATUS READY //=========================================================================================================   Buffers ALLOCint amf_usb_rxtx_buffers_alloc(amf_usb_t *ausb) {	int x;	struct skb_buff	*skb;	int err = -ENOMEM;	ausb->writebuf = KMALLOC(MAX_WRITE_BUF_LEN, GFP_ATOMIC, 1);	if (ausb->writebuf == NULL){		A_DEBUG("%s: Failed to allocate TX buffer!\n", AMF_USB_NAME);		goto error;	}	memset(ausb->writebuf,0x00,MAX_WRITE_BUF_LEN);	amf_set_bit(AMF_USB_LSTATUS_WRITEBUF, &ausb->lstatus);	ausb->readbuf = KMALLOC(MAX_READ_BUF_LEN, GFP_ATOMIC, 2);	if (ausb->readbuf == NULL){		A_DEBUG("%s: Failed to allocate RX buffer!\n", AMF_USB_NAME);		goto error;	}	memset(ausb->readbuf,0x00,MAX_READ_BUF_LEN);	amf_set_bit(AMF_USB_LSTATUS_READBUF, &ausb->lstatus);	AMF_QUE_INIT(&ausb->rx_cmd_free_list);	AMF_QUE_INIT(&ausb->rx_cmd_list);	for(x = 0; x < AMF_USB_MAX_RX_CMD_QLEN; x++){		skb = amf_skb_alloc(10);		if (!skb){			A_DEBUG("%s: Failed to allocate RX cmd buffer!\n", AMF_USB_NAME);			goto error;		}		amf_skb_queue_tail(&ausb->rx_cmd_free_list, skb);	}	amf_set_bit(AMF_USB_LSTATUS_RXCMD, &ausb->lstatus);	AMF_QUE_INIT(&ausb->tx_cmd_free_list);	AMF_QUE_INIT(&ausb->tx_cmd_list);	for(x = 0; x < AMF_USB_MAX_TX_CMD_QLEN; x++){		skb = amf_skb_alloc(10);		if (!skb){			A_DEBUG("%s: Failed to allocate TX cmd buffer!\n", AMF_USB_NAME);			goto error;		}		amf_skb_queue_tail(&ausb->tx_cmd_free_list, skb);	}	amf_set_bit(AMF_USB_LSTATUS_TXCMD, &ausb->lstatus);	return 0;error:	return err;}//=========================================================================================================   Buffers ALLOC END//=========================================================================================================   ENCODE / DECODE   ==========static int amf_usb_rxcmd_decode(amf_usb_t *ausb, u8 *rx_cmd, int rx_cmd_len){	struct sk_buff	*skb;	u8		*cmd;	A_BUG(ausb == NULL);	switch(AMF_USB_CMD_TYPE_DECODE(rx_cmd[0])){	case AMF_USB_CMD_TYPE_WRITE_CPU:		A_DEBUG_TX("%s: Rx Write CPU register (%02X:%02X)!\n", AMF_USB_NAME, (unsigned char)rx_cmd[1], (unsigned char)rx_cmd[2]);		break;	case AMF_USB_CMD_TYPE_READ_CPU:		A_DEBUG_TX("%s: Rx Read CPU register (%02X:%02X)!\n", AMF_USB_NAME, (unsigned char)rx_cmd[1], (unsigned char)rx_cmd[2]);		break;	case AMF_USB_CMD_TYPE_WRITE_FXO:		A_DEBUG_TX("%s: Rx Write FXO register (%02X:%02X)!\n", AMF_USB_NAME, (unsigned char)rx_cmd[1], (unsigned char)rx_cmd[2]);		break;	case AMF_USB_CMD_TYPE_READ_FXO:		A_DEBUG_TX("%s: Rx Read FXO register (%d:%02X)!\n", AMF_USB_NAME, (unsigned char)rx_cmd[1],	(unsigned char)rx_cmd[2]);		break;	case AMF_USB_CMD_TYPE_WRITE_FXS_INDIRECT:		A_DEBUG_TX("%s: Rx Write FXS indirect register (%d:%02X:%02X)!\n", AMF_USB_NAME, (unsigned char)rx_cmd[1], (unsigned char)rx_cmd[2], (unsigned char)rx_cmd[3]);		break;	case AMF_USB_CMD_TYPE_READ_FXS_INDIRECT:		A_DEBUG_TX("%s: Rx Read FXS indirect register (%d:%02X:%02X)!\n", AMF_USB_NAME, (unsigned char)rx_cmd[1], (unsigned char)rx_cmd[2], (unsigned char)rx_cmd[3]);		break;	case AMF_USB_CMD_TYPE_CPU_INIT_PROSLIC:		break;	default:		A_DEBUG_USB("%s: Unknown command %X : %02X!\n", AMF_USB_NAME, AMF_USB_CMD_TYPE_DECODE(rx_cmd[0]), rx_cmd[0]);		ausb->stats.rx_cmd_unknown++;		return -EINVAL;	}	if (amf_skb_queue_len(&ausb->tx_cmd_free_list)){		skb = amf_skb_dequeue(&ausb->rx_cmd_free_list);		cmd = amf_skb_put(skb, rx_cmd_len);		memcpy(cmd, &rx_cmd[0], rx_cmd_len);		amf_skb_queue_tail(&ausb->rx_cmd_list, skb);	}	return 0;}static int amf_usb_rxdata_decode (amf_usb_t *ausb, unsigned char *rxdata){	int			mod_no = 0;	u_int8_t	*rx_data[2];	u_int8_t	rx_cmd[10];	int		rx_cmd_len = 0;	int reg_no = 0;	int data_len_0 = 0;	int i;	u16				control_sum = 0;	unsigned char	control_sum_low = 0;	unsigned char	control_sum_high = 0;	A_BUG(ausb == NULL);	// header was already checked in sync_verify, try it again:	if(0 != memcmp(rxdata, str3, 3)){		A_DEBUG_USB("%s: WARNING: Header (%02X:%02X:%02X:%ld)!\n", AMF_USB_NAME, (unsigned int)rxdata[0], (unsigned int)rxdata[1], (unsigned int)rxdata[2], jiffies);			ausb->stats.rx_start_fr_err_cnt++;		return 1;	}	// control sum	control_sum = 0;	for (i = 3; i < 28; i++) {		control_sum += rxdata[i];	}	control_sum_low = control_sum & 0xFF;	control_sum_high = (control_sum >> 8) & 0xFF;	if ((control_sum_low != rxdata[28]) || (control_sum_high != rxdata[29])) {		A_DEBUG_USB("%s: WARNING: Control sum (%02X:%02X: %02X:%02X: %ld)\n", AMF_USB_NAME, rxdata[28], rxdata[29], control_sum_low, control_sum_high, jiffies);		A_DEBUG_USB("%s: Data Block: %02X:%02X:%02X:%02X:%02X %02X:%02X:%02X:%02X:%02X %02X:%02X:%02X:%02X:%02X %02X:%02X:%02X:%02X:%02X %02X:%02X:%02X:%02X:%02X %02X:%02X:%02X:%02X:%02X  rx_in:%d, rx_out:%d rx_len:%d  %ld)\n", AMF_USB_NAME,				rxdata[0], rxdata[1], rxdata[2], rxdata[3], rxdata[4],				rxdata[5], rxdata[6], rxdata[7], rxdata[8], rxdata[9],				rxdata[10], rxdata[11], rxdata[12], rxdata[13], rxdata[14],				rxdata[15], rxdata[16], rxdata[17], rxdata[18], rxdata[19],				rxdata[20], rxdata[21], rxdata[22], rxdata[23], rxdata[24],				rxdata[25], rxdata[26], rxdata[27], rxdata[28], rxdata[29],				ausb->rx_in, ausb->rx_out, ausb->rx_len,				jiffies);		return 1;	} else {		A_DEBUG_TX("%s: Control sum: OK (%02X:%02X: %02X:%02X: %ld)\n", AMF_USB_NAME, rxdata[28], rxdata[29], control_sum_low, control_sum_high, jiffies);	}	// MCPU Status: Frimware from CPU to PC...	ausb->regs[0][119] = rxdata[3];	//	Wait for 20 seconds before MCPU errors complaining...	if ((rxdata[3] != 0x00) && ausb->bhcount > 20000) {		A_DEBUG_USB("%s%d: MCPU STATUS: %02X\n", AMF_USB_NAME, ausb->order, rxdata[3]);		ausb->stats.mcpu_status_err_cnt++;	}	// commands	if (rxdata[4] != 0x7E) {		memset(rx_cmd, 0, sizeof(rx_cmd));		rx_cmd_len = 4;												// max for fxs indirect		rx_cmd[0] = rxdata[4];		rx_cmd[1] = rxdata[5];		rx_cmd[2] = rxdata[6];		rx_cmd[3] = rxdata[7];										// fxs indirect high		// PROSLIC init in hardware special: we have just received proslic_init acknowlege, so it's time to reset pointers		if (rx_cmd[0] == 0x20) {			ausb->time_to_reset_fifo_pointers = 1;		}		A_DEBUG_RX("%s: Decoding RX Command 0x(%02X:%02X:%02X:%02X) %ld!\n", AMF_USB_NAME, rx_cmd[0], rx_cmd[1], rx_cmd[2], rx_cmd[3], jiffies);		amf_usb_rxcmd_decode(ausb, rx_cmd, rx_cmd_len);	}	// data channel 1// RS>>>	{		struct audio_chunk *chunk = (struct audio_chunk *)KMALLOC(sizeof(struct audio_chunk), GFP_ATOMIC, 3);		if(chunk != NULL){			for (i = 0; i < AMF_USB_CHUNKSIZE; i++) {				chunk->chunk[i] = rxdata[8 + i*2];			}		    	INIT_LIST_HEAD(&chunk->list);			add_node_chunk(chunk, &ausb->dahdi_rx_queue); 		} else {	/* RS>>> todo: handle error */    		}	} 	// data channel 2 MCPU Status:	ausb->regs[0][120] = rxdata[9];			//dci rx read pointer	ausb->regs[0][121] = rxdata[11];		//dci rx write pointer	ausb->regs[0][122] = rxdata[13];		//dci rx bytes in queue	ausb->regs[0][123] = rxdata[15];		//dci tx read pointer	ausb->regs[0][124] = rxdata[17];		//dci tx write pointer	ausb->regs[0][125] = rxdata[19];		//dci tx bytes in queue	ausb->regs[0][126] = rxdata[21];		//MCPU status 2 (from hardware): 0 = Master, 1 = Slave	// test bit!	if (rxdata[21] & 0x20) {		A_DEBUG_USB("%s%d: MCPU report: INDIRECT ACCESS TIMEOUT...\n", AMF_USB_NAME, ausb->order);		ausb->stats.slic_indirect_access_err_cnt++;	}	// FW2: FIFO size was 128 bytes	// if ((ausb->regs[0][122] < 40) || (ausb->regs[0][122] > 80) || (ausb->regs[0][125] < 40) || (ausb->regs[0][125] > 80)) {	// FW3: FIFO size is 48 bytes	if ((ausb->regs[0][122] == 0) || (ausb->regs[0][122] >= 47) || (ausb->regs[0][125] == 0) || (ausb->regs[0][125] >= 47)) {		ausb->stats.mcpu_queue_threshold_err_cnt++;	}	// CPU Registers status (for channel 0 only), 4 registers one by one round-robin every 1 ms	mod_no = 0;	reg_no = rxdata[26];	ausb->regs[mod_no][reg_no] = rxdata[27];	// Temperature	ausb->temperature = rxdata[25] & 0xFF;	ausb->temperature |= ((rxdata[24] << 8) & 0xFF00);	if (ausb->temperature_max < ausb->temperature) {		ausb->temperature_max = ausb->temperature;	}	return 0;}static int amf_usb_rxdata_decode_64 (amf_usb_t *ausb, unsigned char *rxdata){	struct packet_64 *msg = (struct packet_64*)rxdata;	u8	control_sum_low = 0;	u8	control_sum_high = 0;	int	control_sum;	int	i;	u8	mcpu_status;	// header was already checked in sync_verify, try it again:	if(0 != memcmp(msg->sync, str3, sizeof(msg->sync))){		A_DEBUG_USB("%s: WARNING: Header (%02X:%02X:%02X:%ld)!\n", AMF_USB_NAME, (unsigned int)rxdata[0], (unsigned int)rxdata[1], (unsigned int)rxdata[2], jiffies);			ausb->stats.rx_start_fr_err_cnt++;		return 1;	}	// control sum	control_sum = 0; 	for (i = sizeof(msg->sync); i < (sizeof(struct packet_64) - 1); i++) {		control_sum += rxdata[i];	}	control_sum_low = control_sum & 0xFF;//	control_sum_high = (control_sum >> 8) & 0xFF;	if (control_sum_low != msg->chsum_lo){		A_DEBUG_USB("%s: WARNING: Control sum (%02X:%02X: %02X:%02X: %ld)\n", AMF_USB_NAME, rxdata[28], rxdata[29], control_sum_low, control_sum_high, jiffies);		return 1;	} else {		A_DEBUG_TX("%s: Control sum: OK (%02X:%02X: %02X:%02X: %ld)\n", AMF_USB_NAME, rxdata[28], rxdata[29], control_sum_low, control_sum_high, jiffies);	} 	if (msg->cmd.ctrl == 0x20) {		ausb->time_to_reset_fifo_pointers = 1;	}		mcpu_status = msg->mcpu_status;	for(i = 0; i< STATUS_BITS; i++){		if(mcpu_status & 1){			ausb->status_hist[i]++;		}		mcpu_status >>= 1;	}	if(0 == ausb->status_cnt%1000){		if(ausb->status_hist[0] | ausb->status_hist[1] | ausb->status_hist[2] | ausb->status_hist[3] | 			ausb->status_hist[4] | ausb->status_hist[5] | ausb->status_hist[6] | ausb->status_hist[7]){			printk(KERN_INFO "Status #%d: ", ausb->order);			for(i = 0; i< STATUS_BITS; i++){				printk("%d ", ausb->status_hist[i]);				ausb->status_hist[i] = 0;			}			printk("\n");		}	}	ausb->status_cnt ++;	ausb->regs[0][120] = msg->data[1][0];//rxdata[9];		//dci rx read pointer	ausb->regs[0][121] = msg->data[1][2];//rxdata[11];		//dci rx write pointer	ausb->regs[0][122] = msg->data[1][3];//rxdata[13];		//dci rx bytes in queue	ausb->regs[0][123] = msg->data[1][4];//rxdata[15];		//dci tx read pointer	ausb->regs[0][124] = msg->data[1][1];//rxdata[17];		//dci tx write pointer	ausb->regs[0][125] = msg->data[1][5];//rxdata[19];		//dci tx bytes in queue	ausb->regs[0][126] = msg->mcpu_status_2;//rxdata[21];		//MCPU status 2 (from hardware): 0 = Master, 1 = Slave	if(AMF_USB_FXO == ausb->amf_device_type){		ausb->regs[0][4] = msg->status[0];		ausb->regs[0][5] = msg->status[1];		ausb->regs[0][29] = msg->status[2];		ausb->regs[0][34] = msg->status[3]; 	} else if(AMF_USB_FXS == ausb->amf_device_type){ 		ausb->regs[0][8] = msg->status[0];		ausb->regs[0][19] = msg->status[1];		ausb->regs[0][20] = msg->status[2];		ausb->regs[0][24] = msg->status[3];		ausb->regs[0][64] = msg->status[4];		ausb->regs[0][68] = msg->status[5]; 	} 	amf_usb_cmd_xtactor(ausb, &msg->cmd); //	if(OPERATION_STATE == ausb->main_state)		{		for(i = 0; i <  ausb->chunk_size; i++){ //AMF_USB_CHUNKS_PER_PACKET			struct audio_chunk *chunk = (struct audio_chunk *)KMALLOC(sizeof(struct audio_chunk), GFP_ATOMIC, 4);			if(chunk != NULL){				memcpy(chunk->chunk, msg->data[i], AMF_USB_CHUNKSIZE);			    	INIT_LIST_HEAD(&chunk->list); 				add_node_chunk(chunk, &ausb->dahdi_rx_queue);			} else {				/* RS>>> todo: handle error */	    		}		} 	}	}static int amf_usb_txdata_encode(amf_usb_t *ausb, unsigned char *writebuf){	unsigned char	*txdata[2];	int				i;	u16				control_sum = 0;	char			test_writechunk[2][8];	static int		test_cnt = 0;	static char		test_char = 0x11;	struct audio_chunk 	*chunk;static int disp_cnt = 20;#ifdef AMF_USB_MODE_SLAVE	static unsigned long	slave_counter;#endif	test_cnt++;	if ((test_cnt % 2000) == 0) {		if (test_char == 0x11) {			test_char = 0xA5;		} else {			test_char = 0x11;		}	}	if (((test_cnt % 10) == 0) && (test_char != 0x11)) {		if (test_char == 0x5A) {			test_char = 0xA5;		} else {			test_char = 0x5A;		}	}	for (i = 0; i < 8; i++) {		//test_writechunk[0][i] = test_char;		//test_writechunk[1][i] = test_char;		test_writechunk[0][i] = 0x00;		test_writechunk[1][i] = 0x00;	}	A_BUG(ausb == NULL);	memset(writebuf, 0, sizeof(writebuf));	// header	writebuf[0] = 0x7E;	writebuf[1] = 0x5A;	writebuf[2] = 0xA5;	// Control byte: MCPU status 2: 	bit 0:	0 = Master, 1 = Slave	//									bit 1:	0 = Idle, 	1 = FIFOs reset (on Open  	// set HW to Master: writebuf[3] = 0;	writebuf[3] = ausb->master_span_on;#ifdef AMF_USB_MODE_SLAVE	// HW has been transfered to slave!:		1 - wait for 1000 data blocks (1 sec)	//                               			2 - reset hardware FIFOs	//											3 - reset err counters	if (ausb->master_span_on == 1) {		slave_counter++;	} else {		slave_counter = 0;	}	if ((ausb->master_span_on == 1) && (slave_counter == 1000)) {		writebuf[3] |= 1 << 1;		A_DEBUG_USB("%s%d: Resetting pointers: writebuf[3] = %02X\n", AMF_USB_NAME, ausb->order, writebuf[3]);		ausb->stats.mcpu_status_err_cnt = 0;		ausb->stats.mcpu_queue_threshold_err_cnt = 0;	}#endif	// DATA	// number of data bytes(0 - 15): low: channel 0, high: channel 1 (future: dahdi-tx-buffer)	// writebuf[7] = len & 0x0F;	// writebuf[7] |= (len << 4) & 0xF0;	if(AMF_USB_FXO == ausb->amf_device_type){		writebuf[7] = 0x88;	}	// DAHDI TX buffer:// RS>>>	if(!is_list_empty(&ausb->dahdi_tx_queue)){		chunk = get_node_chunk(&ausb->dahdi_tx_queue); 		if(chunk != NULL){ 		} else {		/* RS>>> todo: handle error */			return -ENOMEM;		}	txdata[0] = ausb->writechunk[0];	txdata[1] = ausb->writechunk[1];	// DAHDI RX->TX loopback:	//txdata[0] = ausb->readchunk[0];	//txdata[1] = ausb->readchunk[1];	// Test buffer:	//txdata[0] = test_writechunk[0];	//txdata[1] = test_writechunk[1]; 		for (i = 0; i < 8; i++) {			// channel 0://			writebuf[8 + i*2] = txdata[0][i]; //chunk->chunk[i];			writebuf[8 + i*2] = chunk->chunk[i];			// channel 1://			writebuf[9 + i*2] = txdata[0][i]; //chunk->chunk[i];			writebuf[9 + i*2] = chunk->chunk[i];		} 		KFREE(chunk, 20); 		// commands		if (amf_skb_queue_len(&ausb->tx_cmd_list)){			u8				*cmd;			int				cmd_len;			struct sk_buff	*skb;			skb = amf_skb_dequeue(&ausb->tx_cmd_list);			cmd = amf_skb_data(skb);			cmd_len = amf_skb_len(skb);			writebuf[4] = cmd[0];			writebuf[5] = cmd[1];			writebuf[6] = cmd[2];			if (cmd_len == 4) {				writebuf[7] = cmd[3];			}			if (cmd_len == 2) {				A_DEBUG_TX("%s%d: Encoding TX Command 0x(%02X:%02X) len=%d  %ld!\n", AMF_USB_NAME, ausb->order, writebuf[4], writebuf[5], cmd_len, jiffies);			} else if (cmd_len == 3) {				A_DEBUG_TX("%s%d: Encoding TX Command 0x(%02X:%02X:%02X) len=%d  %ld!\n", AMF_USB_NAME, ausb->order, writebuf[4], writebuf[5], writebuf[6], cmd_len, jiffies);			} else {				A_DEBUG_TX("%s%d: Encoding TX Command 0x(%02X:%02X:%02X:%02X) len=%d  %ld!\n", AMF_USB_NAME, ausb->order, writebuf[4], writebuf[5], writebuf[6], writebuf[7], cmd_len, jiffies);			}			amf_skb_init(skb, 0);			amf_skb_queue_tail(&ausb->tx_cmd_free_list, skb);		} else {			writebuf[4] = AMF_USB_CTRL_IDLE_PATTERN;		}		// Time to reset FXS FIFO pointers in firmware, in case of:		// - RX events enabled:	we have started DAHDI and RX events		// - offhook:			we have received FXS off-hook status		if (ausb->time_to_reset_fifo_pointers == 1) {			ausb->time_to_reset_fifo_pointers = 0;			writebuf[3] |= 1 << 1;			A_DEBUG_USB("%s%d: Resetting pointers and MCPU stats (%02X)  %ld\n", AMF_USB_NAME, ausb->order, writebuf[3], jiffies);			ausb->stats.mcpu_status_err_cnt = 0;			ausb->stats.mcpu_queue_threshold_err_cnt = 0;		}		// Framer status register		writebuf[26] = 0x00;		writebuf[27] = 0x00;		// control sum		control_sum = 0;		for (i = 3; i < 28; i++) {			control_sum += writebuf[i];		}		writebuf[28] = control_sum & 0xFF;		writebuf[29] = (control_sum >> 8) & 0xFF;	}	return 0;}//=========================================================================================================   ENCODE / DECODE.//=========================================================================================================    RX_TX_EVENTS   ==========int amf_usb_rxdata_enable(amf_usb_t *ausb, int enable){	A_BUG(ausb == NULL);	if (enable){		amf_set_bit(AMF_USB_STATUS_RX_DATA_READY, &ausb->status);	}else{		amf_clear_bit(AMF_USB_STATUS_RX_DATA_READY, &ausb->status);	}	return 0;}int amf_usb_rxevent_enable(amf_usb_t *ausb, int mod_no, int enable){	int		event_bit;	u8		mask;	A_BUG(ausb == NULL);	if (mod_no) mask = AMF_USB_CPU_BIT_CTRL_TS1_EVENT_EN;	else mask = AMF_USB_CPU_BIT_CTRL_TS0_EVENT_EN;	if (enable) ausb->reg_cpu_ctrl |= mask;	else ausb->reg_cpu_ctrl &= ~mask;	__amf_usb_cpu_write(ausb, AMF_USB_CPU_REG_CTRL, ausb->reg_cpu_ctrl);	event_bit = (mod_no) ? AMF_USB_STATUS_RX_EVENT2_READY : AMF_USB_STATUS_RX_EVENT1_READY;	amf_set_bit(event_bit, &ausb->status);	return 0;}int amf_usb_rxevent(amf_usb_t *ausb, int mod_no, int force){	int		event_bit;	A_BUG(ausb == NULL);	event_bit = (mod_no) ? AMF_USB_STATUS_RX_EVENT2_READY : AMF_USB_STATUS_RX_EVENT1_READY;	if(!test_bit(event_bit, (unsigned long *)&ausb->status)){		return -EINVAL;	}	if (force){		//ausb->regs[mod_no][5]  = __amf_usb_fxo_read(ausb, mod_no, 5);		//ausb->regs[mod_no][29] = __amf_usb_fxo_read(ausb, mod_no, 29);		//ausb->regs[mod_no][34] = __amf_usb_fxo_read(ausb, mod_no, 34);		//ausb->regs[mod_no][4]  = __amf_usb_fxo_read(ausb, mod_no, 4);	}	return 0;}typedef void (*deb_store_t)(u8*, rel2exchange_t, u8);deb_store_t deb_store = NULL;static int	amf_rx_tx_span(amf_usb_t *ausb) {	int mod_no = 0;	int i;	u8* rxdata = (u8*) ausb->context;	struct audio_chunk *chunk;	while(!is_list_empty(&ausb->dahdi_rx_queue)){// RS>>> /*		if(is_list_empty(&ausb->dahdi_rx_queue)){			return 0;		}*/		chunk = get_node_chunk(&ausb->dahdi_rx_queue);	    	INIT_LIST_HEAD(&chunk->list); 		//		if (amf_test_bit(AMF_USB_LSTATUS_DAHDI, &ausb->lstatus)){{ 			if (ausb->isrcount % 2 == 0){				if (ausb->mod_type[0] == AMF_USB_FXS){					amf_proslic_check_ohttimer(ausb, 0);					amf_proslic_check_hook(ausb, 0);				} else {					amf_voicedaa_check_hook(ausb, 0);				}			}			if (!(ausb->isrcount & 0xF0)){				if (ausb->mod_type[0] == AMF_USB_FXS){					amf_proslic_recheck_sanity(ausb, 0);				} else {					amf_voicedaa_recheck_sanity(ausb, 0);				}			}			ausb->chans[mod_no].readchunk = ausb->chans[mod_no].writechunk = &chunk->chunk[0];//			for (mod_no = 0; mod_no < ausb->mod_cnt; mod_no++) {				dahdi_ec_chunk(&ausb->chans[mod_no], ausb->chans[mod_no].readchunk, ausb->lasttx[mod_no]);//			}			ausb->chunk_amount++;			if(deb_store){ 				deb_store(ausb->chans[mod_no].readchunk, PRE_EXCHANGE, ausb->order);			}			dahdi_receive(&ausb->span);			dahdi_transmit(&ausb->span);                        if(deb_store){				deb_store(ausb->chans[mod_no].writechunk, POST_EXCHANGE, ausb->order);                        }					   //			for (mod_no = 0; mod_no < ausb->mod_cnt; mod_no++) {				memcpy(ausb->lasttx[mod_no], ausb->chans[mod_no].writechunk, DAHDI_CHUNKSIZE);//			}		} 		add_node_chunk(chunk, &ausb->dahdi_tx_queue);			}	return 0;}//=========================================================================================================    RX_TX_EVENTS END//=========================================================================================================    ISR   ==========void amf_usb_isr(void *arg){	amf_usb_t		*ausb = (amf_usb_t*)arg;	int i;	ausb->isrcount++;	for (i = 0; i < ausb->mod_cnt; i++) {		amf_usb_rxevent(ausb, i, 0);	}	amf_rx_tx_span(ausb);	return;}//=========================================================================================================  TASKLET  ==========int amf_usb_txdata_prepare(amf_usb_t *ausb, char *writebuf, int len){	int		tx_in;	int		tx_out;	int		urb_write_ind;	int		err;	struct usb_tx_urb* tx_urb_item;	//RS>>>	while(1){		tx_urb_item = get_node_urb(&ausb->usb_tx_queue.head);		if(NULL == tx_urb_item){			return 0; //RS>>> Done		}		err = usb_submit_urb(&tx_urb_item->urb, GFP_ATOMIC);		if (err != 0) {			if (err != -ENOENT) {				A_DEBUG("%s: Failed to program transmitter (%ld)!\n", AMF_USB_NAME, jiffies);			}			ausb->stats.tx_notready_cnt++;			return  -EINVAL;		}	}	return 0;}int amf_usb_txdata_send(amf_usb_t *ausb){	int		tx_in;	int		tx_out;	int		urb_write_ind;	int		err;	struct usb_tx_urb* tx_urb_item;	//RS>>>	while(1){		tx_urb_item = get_node_urb(&ausb->usb_tx_queue.head);		if(NULL == tx_urb_item){			return 0; //RS>>> Done		}		err = usb_submit_urb(&tx_urb_item->urb, GFP_ATOMIC);		if (err != 0) {			if (err != -ENOENT) {				A_DEBUG("%s: Failed to program transmitter (%ld)!\n", AMF_USB_NAME, jiffies);			}			ausb->stats.tx_notready_cnt++;			return  -EINVAL;		}	}}static int amf_usb_buflen(int rx_in, int rx_out, int max){	int	rx_len;	if (rx_in >= rx_out){		rx_len = rx_in - rx_out;	} else {		rx_len = max - rx_out + rx_in;	}	return rx_len;}static int amf_usb_rxdata_get_raw(amf_usb_t *ausb, unsigned char *rxdata, int max_len){	int		rx_len;	int 	i;	int		rx_out = 0;	int		rx_in = 0;			A_BUG(ausb == NULL);	rx_in = ausb->rx_in;	rx_out = ausb->rx_out;	if (rx_in > rx_out){		rx_len = rx_in - rx_out; 	}else if (rx_in < rx_out){							rx_len = MAX_READ_BUF_LEN - rx_out + rx_in;	}else{		return 0;	}	if (rx_len > max_len) rx_len = max_len;                         	if (rx_len > MAX_USB_RX_LEN) rx_len = MAX_USB_RX_LEN;	for (i = 0; i < rx_len; i++) {		rxdata[i] = ausb->readbuf[rx_out];		rx_out++;		if (rx_out == MAX_READ_BUF_LEN) {			rx_out = 0;		}			}	ausb->rx_out = rx_out;		return rx_len;}static int amf_usb_rxdata_get(amf_usb_t *ausb, unsigned char *rxdata, int max_len){	int		rx_len;	int 	i;	int		rx_out = 0;	int		rx_in = 0;	max_len = MAX_USB_RX_LEN;	A_BUG(ausb == NULL);	rx_in = ausb->rx_in;	rx_out = ausb->rx_out;	rx_len = amf_usb_buflen(rx_in, rx_out, MAX_READ_BUF_LEN);	if (0 == rx_len){		return -1;	}	if(max_len > rx_len){		return -2;	/* Not enough data yet */	}	if (rx_len > MAX_USB_RX_LEN){		rx_len = MAX_USB_RX_LEN;	}	if(MAX_READ_BUF_LEN <= rx_out + max_len){		int first;		first = MAX_READ_BUF_LEN - rx_out;		i = memcpy(rxdata, &ausb->readbuf[rx_out], first);		rx_len -= first;		rx_out = rx_len;		memcpy(&rxdata[first], &ausb->readbuf[0], rx_len);	} else {		memcpy(rxdata, &ausb->readbuf[rx_out], rx_len);		rx_out += rx_len;	}ausb->handled += rx_len;	ausb->rx_out = rx_out; 	rx_len = amf_usb_buflen(rx_in, rx_out, MAX_READ_BUF_LEN);	return rx_len;}static int amf_usb_bh_rx (amf_usb_t *ausb){	int			rx_len, len;	u_int8_t	readbuf[MAX_USB_RX_LEN];	int 		datablocks_num;	int k;	A_BUG(ausb == NULL);/*	if(ausb->firmwareupdate ){			amf_usb_rxdata_get_raw(ausb, &readbuf[0], MAX_USB_RX_LEN);			return 0;	}*/	for(rx_len = MAX_USB_RX_LEN; rx_len >= MAX_USB_RX_LEN;) 	{		int i; 		rx_len = amf_usb_rxdata_get(ausb, &readbuf[0], MAX_USB_RX_LEN); // MAX_READ_BUF_LEN 		if(0 > rx_len){			return 0;		}		amf_usb_rxdata_decode_64(ausb, readbuf); 		ausb->context = readbuf;		if(OPERATION_STATE == ausb->main_state){			amf_rx_tx_span(ausb);		} else {			/* Release  */			struct audio_chunk *chunk;			chunk = get_node_chunk(&ausb->dahdi_rx_queue);			if(NULL == chunk){				return 0;			}			KFREE(chunk, 34);		}	}	return 0;}static int amf_usb_bh_tx(amf_usb_t *ausb){	unsigned char	writebuf[MAX_USB_TX_LEN];	int err;	int i;	amf_usb_create_packet_64(ausb);	amf_usb_txdata_send_64(ausb);	return 0;}int amf_usb_txdata_create(amf_usb_t *ausb, u8 *writebuf){	struct usb_tx_urb* tx_urb_item = KMALLOC(sizeof(struct usb_tx_urb), GFP_ATOMIC, 6);	if(NULL == tx_urb_item){		return -ENOMEM;	}	amf_usb_init_tx_urb(ausb, tx_urb_item);	INIT_LIST_HEAD(&tx_urb_item->list);	tx_urb_item->ausb = ausb; 	add_node_fill_urb_data(&tx_urb_item, writebuf, &ausb->usb_tx_queue.head);	return 0;}void amf_usb_bh (unsigned long data){	amf_usb_t		*ausb = (amf_usb_t*)data;	A_BUG(ausb == NULL);	if (amf_test_and_set_bit(AMF_USB_STATUS_BH, &ausb->status)){		A_DEBUG("%s: [BH:%ld]: Re-entry in USB BH!\n", AMF_USB_NAME, jiffies);		goto usb_bh_done;	}	ausb->bhcount++;	if ((ausb->mod_type[0] == AMF_USB_FXO) && (ausb->failover_enabled)) {		if ((ausb->bhcount % 500) == 0) {			A_DEBUG_TX("%s%d: WATCHDOG: %ld\n", AMF_USB_NAME, ausb->order, jiffies);			__amf_usb_cpu_write(ausb, AMF_USB_CPU_REG_WATCHDOG, AMF_USB_CPU_WATCHDOG_RESTART);		}	}	// If we are called by Master, do receive and transmit!	// If we are called by Slave: data will be checked in get!	/* receive path */	amf_usb_bh_rx(ausb);	/* transmit path */	amf_usb_bh_tx(ausb);	amf_clear_bit(AMF_USB_STATUS_BH, &ausb->status);usb_bh_done:usb_bh_exit:	return;}//=========================================================================================================  TASKLET (end)//=========================================================================================================  RAW TX/RX  =========int amf_usb_txdata_raw(amf_usb_t *ausb, unsigned char *data, int max_len){	int		err = 0;	struct usb_tx_urb* tx_urb_item = KMALLOC(sizeof(struct usb_tx_urb), GFP_ATOMIC, 7);	//RS>>>	// raw read/write is still in 32-byte frames	if (max_len > 32){		max_len = 32;	}	if(NULL == tx_urb_item){		return -ENOMEM;	}	INIT_LIST_HEAD(&tx_urb_item->list);	(max_len < sizeof(tx_urb_item->data)) ? max_len : sizeof(tx_urb_item->data);	amf_usb_init_tx_urb_len(ausb, tx_urb_item, max_len);	memcpy(tx_urb_item->data, data, max_len);	tx_urb_item->ausb = ausb;	add_node_urb(tx_urb_item,  &ausb->usb_tx_queue);	err = amf_usb_txdata_prepare(ausb, data, max_len);	return (!err) ? max_len : 0;}int amf_usb_txdata_raw_ready(amf_usb_t *ausb){	if (!amf_test_bit(AMF_USB_STATUS_TX_READY, &ausb->status)){		return -EBUSY;	}	return 0;}int amf_usb_rxdata_raw(amf_usb_t *ausb, unsigned char *data, int max_len){	int		rxlen = 0;	// raw read/write is still in 32-byte frames	if (max_len > 32){		max_len = 32;	}	rxlen = amf_usb_rxdata_get_raw(ausb, data, max_len);	return rxlen;}int amf_usb_rxurb_reset(amf_usb_t *ausb){	int		x, i;	int		err = 0;	for (i = 0; i < AMF_URB_AMOUNT; i++){		ausb->rx_in = 0;		ausb->rx_out = 0;		for (x = 0; x < ausb->urbcount_read; x++){			ausb->urbread[x][i].indx = i;			ausb->urbread[x][i].urb.transfer_buffer = &ausb->readbuf_block[i][0];			err = usb_submit_urb(&ausb->urbread[x][i].urb, GFP_ATOMIC);			if ((err != 0) && (err != -ENOENT)) {				A_DEBUG("%s: Failed to start Raw RX transfer: %d %d\n", AMF_USB_NAME, x, i);				return  -EINVAL;			}		}	}	return 0;}int amf_usb_txurb_reset(amf_usb_t *ausb){	ausb->tx_in = 0;	ausb->tx_out = 0;	return 0;}//===================================================================/* RS>>> QUEUE *///void add_new_node_chunk(u8* data, struct list_head *head)void add_new_node_chunk(u8* data, queue_head_t *queue){	struct audio_chunk *chunk = (struct audio_chunk *)KMALLOC(sizeof(struct audio_chunk), GFP_ATOMIC, 8);	unsigned long flags;	if(chunk != NULL){    		memcpy(chunk->chunk, data, AMF_USB_CHUNKSIZE);    		INIT_LIST_HEAD(&chunk->list);		spin_lock_irqsave(&queue->list_lock, flags);    		list_add(&chunk->list, &queue->head);		spin_unlock_irqrestore(&queue->list_lock, flags);	} else {		/* RS>>> todo: handle error */	}}void add_node_chunk_data(struct audio_chunk *chunk, u8* data, queue_head_t *queue){	unsigned long flags;	memcpy(chunk->chunk, data, AMF_USB_CHUNKSIZE);	spin_lock_irqsave(&queue->list_lock, flags);	list_add(&chunk->list, &queue->head);	spin_unlock_irqrestore(&queue->list_lock, flags);} void add_node_fill_urb_data(struct usb_tx_urb *tx_urb, u8* data, queue_head_t *queue){	unsigned long flags;	memcpy(tx_urb->data, data, MAX_USB_TX_LEN);	spin_lock_irqsave(&queue->list_lock, flags);	list_add(&tx_urb->list, &queue->head);	spin_unlock_irqrestore(&queue->list_lock, flags);}void add_node_chunk (struct audio_chunk *chunk, queue_head_t *queue){	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);    	list_add(&chunk->list, &queue->head);	spin_unlock_irqrestore(&queue->list_lock, flags);}void add_node_urb (struct usb_tx_urb *urb, queue_head_t *queue){	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);    	list_add(&urb->list, &queue->head);	spin_unlock_irqrestore(&queue->list_lock, flags);}/*void delete_all(queue_head_t *queue){    struct list_head *iter;    struct audio_chunk *objPtr;    unsigned long flags;redo:	spin_lock_irqsave(&queue->list_lock, flags);	__list_for_each(iter, head) {	spin_unlock_irqrestore(&queue->list_lock, flags);        objPtr = list_entry(iter, struct audio_chunk, list);	spin_lock_irqsave(&queue->list_lock, flags);        list_del(&objPtr->list);	spin_unlock_irqrestore(&queue->list_lock, flags);        KFREE(objPtr, 21);        goto redo;    }}*/int is_list_empty(queue_head_t *queue){	unsigned long flags;	int ret_val;	spin_lock_irqsave(&queue->list_lock, flags);	ret_val = list_empty(&queue->head);	spin_unlock_irqrestore(&queue->list_lock, flags);	return ret_val;}struct audio_chunk *get_node_chunk(queue_head_t *queue){	struct audio_chunk *objPtr;	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);	objPtr = list_last_entry_or_null(&queue->head, struct audio_chunk, list);	if(objPtr){		list_del(&objPtr->list);	}	spin_unlock_irqrestore(&queue->list_lock, flags);	return objPtr;}struct usb_tx_urb *get_node_tx_urb(queue_head_t *queue){	struct usb_tx_urb *objPtr;	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);	objPtr = list_last_entry_or_null(&queue->head, struct usb_tx_urb, list);	if(objPtr){		list_del(&objPtr->list);	}	spin_unlock_irqrestore(&queue->list_lock, flags);	return objPtr;}struct usb_tx_urb *get_node_urb(queue_head_t *queue){	struct usb_tx_urb *objPtr;	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);	objPtr = list_last_entry_or_null(&queue->head, struct usb_tx_urb, list);	if(objPtr){		list_del(&objPtr->list);	}	spin_unlock_irqrestore(&queue->list_lock, flags);	return objPtr;}struct list_head *peek_node_chunk(queue_head_t *queue){	struct audio_chunk *objPtr;	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);	objPtr = list_last_entry_or_null(&queue->head, struct audio_chunk, list);	spin_unlock_irqrestore(&queue->list_lock, flags);	return objPtr;}int count_queue_elements(queue_head_t *queue){	struct list_head* head = &queue->head;	struct list_head* tmp = &queue->head;	unsigned long flags;	int i;		spin_lock_irqsave(&queue->list_lock, flags);	for(i = 0; tmp->next != head; i++){		tmp = tmp->next;	}	spin_unlock_irqrestore(&queue->list_lock, flags);	return i;}struct list_head *peek_node_tx_urb(queue_head_t *queue){	struct usb_tx_urb *objPtr;	unsigned long flags;	spin_lock_irqsave(&queue->list_lock, flags);	objPtr = list_last_entry_or_null(&queue->head, struct usb_tx_urb, list);	spin_unlock_irqrestore(&queue->list_lock, flags);	return objPtr;}int amf_usb_txdata_send_64(amf_usb_t *ausb){	int		tx_in;	int		tx_out;	int		urb_write_ind;	int		err;	struct usb_tx_urb* tx_urb_item;	//RS>>> 	while(1){			tx_urb_item = get_node_urb(&ausb->usb_tx_queue);		if(NULL == tx_urb_item){			return 0; //RS>>> Done		}  		err = usb_submit_urb(&tx_urb_item->urb, GFP_ATOMIC);		if (err != 0) {			if (err != -ENOENT) {				A_DEBUG("%s: Failed to program transmitter (%ld)!\n", AMF_USB_NAME, jiffies);			}			ausb->stats.tx_notready_cnt++;			return  -EINVAL;		}	}	return 0;}/**  * Create a 64 bit packet.  * Take chunks from ausb->dahdi_tx_queue  * Take CPU register comand from ausb->reg_access_tx_head  * Place the competely initialized packet to the ausb->usb_tx_queue*/int amf_usb_create_packet_64(amf_usb_t *ausb){	int i;	struct audio_chunk 	*chunk;	struct packet_64* pkt;	u8* dst;	u8* src;	u8* ptr;	cpu_reg_cmd_t* cmd;	struct reg_access_item* ra_item;	struct usb_tx_urb* tx_urb_item = KMALLOC(sizeof(struct usb_tx_urb), GFP_ATOMIC, 9); 	if(NULL == tx_urb_item){		return -ENOMEM;	} 	amf_usb_init_tx_urb(ausb, tx_urb_item);	INIT_LIST_HEAD(&tx_urb_item->list);	pkt = (struct packet_64*)tx_urb_item->data;	ptr = tx_urb_item->data;	tx_urb_item->ausb = ausb;	/* Fill a Sync field */	memcpy(pkt->sync, str3, SYNC_SIZE);		/*Master/Slave switch: 0 - Master; 1 - Slave*/	pkt->mcpu_status = ausb->master_span_on;	/* Fill AMF_USB_CHUNKS_PER_PACKET chunks */ 	while(count_queue_elements(&ausb->dahdi_tx_queue) >= 6){		for(i = 0; i < ausb->chunk_size; i++){			chunk = get_node_chunk(&ausb->dahdi_tx_queue);			if(chunk != NULL){				memcpy(pkt->data[i], chunk->chunk, AMF_USB_CHUNKSIZE);                       if(deb_store){				deb_store(&pkt->data[i][0], POST_EXCHANGE, ausb->order);                        }				KFREE(chunk, 22);			} else {				break;			}		}		if(i < AMF_USB_CHUNKS_PER_PACKET){			memset(pkt->data[i], 0, AMF_USB_CHUNKS_PER_PACKET - i);		}	}	/* Fill command to access CPU registers */	ra_item = get_cmd_from_queue(&ausb->reg_access_tx_head);		if(ra_item){		cmd = &ra_item->cmd;		if(AMF_USB_FXO == ausb->amf_device_type){			cmd->high = 0x88;		}		memcpy((u8*)&(pkt->cmd), cmd, sizeof(cpu_reg_cmd_t));		KFREE(ra_item, 23);	} else {		memset((u8*)&(pkt->cmd), 0, sizeof(cpu_reg_cmd_t));		pkt->cmd.ctrl = NO_COMMAND;	}	memset(&pkt->status, 0, sizeof(pkt->status));	pkt->mcpu_status_2 = 0;	/* Calculate a checksum */	pkt->chsum_lo = 0;	ptr += SYNC_SIZE;	for(i = SYNC_SIZE; i < (sizeof(struct packet_64) - 1); i++ ){		pkt->chsum_lo += *ptr;		ptr++;	}	add_node_urb(tx_urb_item,  &ausb->usb_tx_queue);	return 0;}#if 0Examples of the DMA USBhttp://lxr.free-electrons.com/source/sound/usb/misc/ua101.c?v=3.18http://lxr.free-electrons.com/source/drivers/net/can/usb/esd_usb2.c#L583#endifEXPORT_SYMBOL(deb_store);